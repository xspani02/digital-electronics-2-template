# Lab 2: Control of GPIO, LED, push button

![Arduino Uno](images/arduino_uno_leds.jpg)

### Learning objectives

After completing this lab you will be able to:

* Use LEDs and push buttons
* Config input/output ports of AVR using control registers
* Use ATmega328P manual and find information
* Use breadboard and connect electronic devices to AVR pins

The purpose of this laboratory exercise is to learn how to use basic input/output devices such as LEDs (Light Emitting Diodes) and push buttons, and how to control GPIO (General Purpose Input Output) pins with help of control registers.

### Table of contents

* [Preparation tasks](#preparation)
* [Part 1: Synchronize Git and create a new folder](#part1)
* [Part 2: Active-low and active-high LEDs](#part2)
* [Part 3: Push button](#part3)
* [Part 4: Switch debouncing](#part4)
* [Experiments on your own](#experiments)
* [Lab assignment](#assignment)
* [References](#references)

<a name="preparation"></a>

## Preparation tasks (done before the lab at home)
 
1. Draw two basic ways to connect a LED to the output pin of the microcontroller: LED active-low, LED active-high.

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

2. [Calculate LED resistor value](https://electronicsclub.info/leds.htm) for typical LEDs. Let the LED current is 20 milli amps.

&nbsp;
   ![ohms law](images/ohms_law.png)
&nbsp;

   | **LED color** | **Supply voltage** | **LED current** | **LED voltage** | **Resistor value** |
   | :-: | :-: | :-: | :-: | :-: |
   | red | 5&nbsp;V | 20&nbsp;mA | 2&nbsp;V | 150&nbsp;ohm |
   | green | 5&nbsp;V | | 2.2&nbsp;V | |
   | blue | 5&nbsp;V | | 3.3&nbsp;V | |

> Note that, equation was generated by [Online LaTeX Equation Editor](https://www.codecogs.com/latex/eqneditor.php) using the following code.

```LaTeX
R = \frac{V_{SUPPLY}-V_{LED}}{I} =
```
>

3. Draw the basic ways to connect a push button to the microcontroller input pin: button active-low, button active-high.

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

<a name="part1"></a>

## Part 1: Synchronize repositories and create a new folder

When you start working, always synchronize the contents of your working folder and local repository with remote version at GitHub. This way you are sure that you will not lose any of your changes.

Run Git Bash (Windows) of Terminal (Linux), navigate to your working directory, and update local repository.

```bash
## Windows Git Bash:
$ cd d:/Documents/
$ cd your-name/
$ ls
digital-electronics-2/
$ cd digital-electronics-2/
$ git pull

## Linux:
$ cd
$ cd Documents/
$ cd your-name/
$ ls
digital-electronics-2/
$ cd digital-electronics-2/
$ git pull
```

Create a new working folder `labs/02-leds` for this exercise.

```bash
## Windows Git Bash or Linux:
$ cd labs/
$ mkdir 02-leds
```

<a name="part2"></a>

## Part 2: Active-low and active-high LEDs

AVR microcontroller associates pins into so-called ports, which are marked with the letters A, B, C, etc. Each of the pins is controlled separately and can function as an input (entry) or output (exit) point of the microcontroller. Control is possible exclusively by software via control registers.

There are exactly three control registers for each port: DDR, PORT and PIN, supplemented by the letter designation of the port. For port A these are registers DDRA, PORTA and PINA, for port B registers DDRB, PORTB, PINB, etc.

DDR (Data Direction Register) is used to set the input/output direction of port communication, PORT is the output data port and PIN works for reading input values from the port.

A detailed description of working with input/output ports can be found in [ATmega328P datasheet](https://www.microchip.com/wwwproducts/en/ATmega328p) in section I/O-Ports.

1. Use the datasheet to find out the meaning of the DDRB and PORTB control register values and their combinations. (Let PUD (Pull-up Disable) bit in MCUCR (MCU Control Register) is 0 by default.)

   | **DDRB** | **PORTB** | **Direction** | **Internal pull-up resistor** | **Description** |
   | :-: | :-: | :-: | :-: | :-- |
   | 0 | 0 | input | no | Tri-state, high-impedance |
   | 0 | 1 | | | |
   | 1 | 0 | | | |
   | 1 | 1 | | | |

2. See [schematic of Arduino Uno board](https://oshwlab.com/tomas.fryza/arduino-shields) in docs folder of Digital-electronics-2 repository and find out which pins of ATmega328P can be used as input/output pins. To which pin is the LED L connected? Is it connected as active-low or active-high? Note that labels on Arduino `~3`, `~5`, etc. do not mean that the signals are inverted; the `~` symbol indicates that a PWM (Pulse-width modulation) signal can be generated on these pins.

   | **Port** | **Pin** | **Input/output usage?** |
   | :-: | :-: | :-- |
   | A | x | Microcontroller ATmega328P does not contain port A |
   | B | 0 | Yes (Arduino pin 8) |
   |   | 1 |  |
   |   | 2 |  |
   |   | 3 |  |
   |   | 4 |  |
   |   | 5 |  |
   |   | 6 |  |
   |   | 7 |  |
   | C | 0 | Yes (Arduino pin A0) |
   |   | 1 |  |
   |   | 2 |  |
   |   | 3 |  |
   |   | 4 |  |
   |   | 5 |  |
   |   | 6 |  |
   |   | 7 |  |
   | D | 0 | Yes (Arduino pin RX<-0) |
   |   | 1 |  |
   |   | 2 |  |
   |   | 3 |  |
   |   | 4 |  |
   |   | 5 |  |
   |   | 6 |  |
   |   | 7 |  |

3. Use breadboard (or SimulIDE real time electronic circuit simulator), connect resistor and second LED to Arduino output pin in active-low way. **Let the second LED is connected to port C.**

### Version: Atmel Studio 7

1. Create a new GCC C Executable Project for ATmega328P within `02-leds` working folder and copy/paste [template code](main.c) to your `main.c` source file.

2. Complete the control register settings according to the pin to which you have connected the second LED. Program an application that blinks alternately with a pair of LEDs. Use the delay library as in the previous exercise.

3. Compile the project. Simulate the project in Atmel Studio 7.

4. Run external programmer in menu **Tools > Send to Arduino UNO** and download the compiled code to Arduino Uno board or load `*.hex` firmware to SimulIDE circuit. Observe the correct function of the application using the flashing LEDs.

### Version: Command-line toolchain

1. Copy `main.c` and `Makefile` files from previous lab to `labs/02-leds` folder. Check if `Makefile.in` settings file exists in `Labs` folder.

2. Copy/paste [template code](main.c) to your `main.c` source file.

3. Complete the control register settings according to the pin to which you have connected the second LED. Program an application that blinks alternately with a pair of LEDs. Use the delay library as in the previous exercise.

4. Compile the project with the `mingw32-make.exe all` (Windows) or `make all` (Linux).

5. Download the compiled code to Arduino Uno board with `mingw32-make.exe flash` (Windows) or `make flash` (Linux) or load `*.hex` firmware to SimulIDE circuit. Observe the correct function of the application using the flashing LEDs.

<a name="part3"></a>

## Part 3: Push button

1. Use breadboard (or SimulIDE real time electronic circuit simulator), connect resistor (if internal pull-up resistor is not used) and push button to Arduino input pin in active-low way. **Let the push button is connected to port D.**

2. Use code from previous part and program an application that toggles LEDs only if push button is pressed. Otherwise, the value of the LEDs does not change.

3. Configure the pin to which the push button is connected as an input and enable the internal pull-up resistor.

4. Use Special function registers from [AVR Libc](https://onlinedocs.microchip.com/) to test bit values in control registers (you need to include library `#include <avr/sfr_defs.h>`). Complete the code, compile it and download to Arduino Uno board or load `*.hex` firmware to SimulIDE circuit. Observe the correct function of the application using the flashing LEDs and the push button.

   | **Function** | **Example** | **Description** |
   | :-- | :-- | :-- |
   | `bit_is_set(reg_name, pin_num)` | `if (bit_is_set(PINA, 3)) {...}` | Perform the code only if bit number 3 in register PINA is 1 (set) |
   | `bit_is_clear(reg_name, pin_num)` | `if (bit_is_clear(PINB, 5)) {...}` | Perform the code only if bit number 5 in register PINB is 0 (clear) |
   | `loop_until_bit_is_set(reg_name, pin_num)` | `loop_until_bit_is_set(PIND, 0);` | Stay here until bit number 0 in register PIND becomes 1 |
   | `loop_until_bit_is_clear(reg_name, pin_num)` | `loop_until_bit_is_clear(PINA, 7);` | Stay here until bit number 7 in register PINA becomes 0 |

<a name="part4"></a>

## Part 4: Switch debouncing (hardware implementation only)

*[Bouncing](https://whatis.techtarget.com/definition/debouncing) is the tendency of any two metal contacts in an electronic device to generate multiple signals as the contacts close or open; debouncing is any kind of hardware device or software that ensures that only a single signal will be acted upon for a single opening or closing of a contact.*

![Real push button signal with bouncing](images/debouncer.png)

Use AVR Libc and time delay library functions to debounce a push button. Create an application that samples the input signal and decides that the push button was pressed based on a series of the same values, eg. four zero bits consecutively present on the input pin.

![Decouncer](images/debouncer_algo.png)

## Synchronize git

When you finish working, always synchronize the contents of your working folder with the local and remote versions of your repository. This way you are sure that you will not lose any of your changes.

Use [git commands](https://github.com/tomas-fryza/digital-electronics-2/wiki/Useful-Git-commands) to add, commit, and push all local changes to your remote repository. Check the repository at GitHub web page for changes.

<a name="experiments"></a>

## Experiments on your own

1. Connect at least five LEDs and a push button to the microcontroller, modify `02-leds` code, and program an application in [Knight Rider style](https://www.youtube.com/watch?v=w-P-2LdS6zk). When you press and release a push button once, the LEDs starts to switched on and off; ensure that only one of LEDs is switched on at a time. Do not implement the blinking speed changing.

2. Simulate the Knight Rider application in SimulIDE.

Extra. Program the [PWM generator](https://www.analogictips.com/pulse-width-modulation-pwm/) using the delay library. Let the duty cycle of the PWM signal be changed continuously and the signal is connected to one of the LEDs. How does a change of duty cycle affect the brightness of an LED?

<a name="assignment"></a>

## Lab assignment

*Prepare all parts of the assignment in Czech, Slovak or English according to this [template](assignment.md), export formatted output (not Markdown) [from HTML to PDF](https://github.com/tomas-fryza/digital-electronics-2/wiki/Export-README-to-PDF), and submit a single PDF file via [BUT e-learning](https://moodle.vutbr.cz/). The deadline for submitting the task is the day before the next laboratory exercise.*

> *Vypracujte všechny části úkolu v českém, slovenském, nebo anglickém jazyce podle této [šablony](assignment.md), exportujte formátovaný výstup (nikoli výpis v jazyce Markdown) [z HTML do PDF](https://github.com/tomas-fryza/digital-electronics-2/wiki/Export-README-to-PDF) a odevzdejte jeden PDF soubor prostřednictvím [e-learningu VUT](https://moodle.vutbr.cz/). Termín odevzdání úkolu je den před dalším počítačovým cvičením.*
>

<a name="references"></a>

## References

1. Microchip Technology Inc. [ATmega328P datasheet](https://www.microchip.com/wwwproducts/en/ATmega328p)

2. Tomas Fryza. [Schematic of Arduino Uno board](https://oshwlab.com/tomas.fryza/arduino-shields)

3. Microchip Technology Inc. [AVR Libc](https://onlinedocs.microchip.com/)

4. TechTarget. [Debouncing](https://whatis.techtarget.com/definition/debouncing)

5. Tomas Fryza. [Useful Git commands](https://github.com/tomas-fryza/digital-electronics-2/wiki/Useful-Git-commands)

6. norwega. [Knight Rider style chaser](https://www.youtube.com/watch?v=w-P-2LdS6zk)

7. Janet Heath. [PWM: Pulse Width Modulation: What is it and how does it work?](https://www.analogictips.com/pulse-width-modulation-pwm/)
